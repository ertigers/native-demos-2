<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
<script>
// 选择排序的for循环写法
let sort = (numbers)=>{
  for(let i = 0;i<numbers.length-1;i++) {
    let index = minIndex(numbers.slice(i)) + i
    if(index !== i) swap(numbers,index,i)
  }
  return numbers
}
let swap = (numbers,index,i) =>{
  let tem = numbers[index]
  numbers[index] = numbers[i]
  numbers[i] = tem
}
let minIndex = (numbers) =>{
  let index = 0
  for(let i=0;i<numbers.length;i++){
    if(numbers[i]<numbers[index]) {
      index = i
    }
  }
  return index
}

// 快速排序
let quickSort = arr=>{
  if(arr.length <= 1) return arr
  let pivotIndex = Math.floor(arr.length/2)
  let pivot = arr.splice(pivotIndex,1)[0]
  let left = []
  let right = []
  for(let i=0;i<arr.length;i++) {
    if(arr[i]<pivot) {
      left.push(arr[i])
    }else {
      right.push(arr[i])
    }
  }
  return quickSort(left).concat([pivot], quickSort(right))
}

// 归并排序
let mergeSort = arr=>{
  if(arr.length <= 1) return arr
  let left = arr.slice(0,Math.floor(arr.length/2))
  let right = arr.slice(Math.floor(arr.length/2))
  return merge(mergeSort(left),mergeSort(right))
}
let merge = (a,b)=>{
  if(a.length === 0) return b
  if(b.length === 0) return a 
  return a[0]<b[0] ? [a[0]].concat(merge(a.slice(1), b)) 
                   : [b[0]].concat(merge(a, b.slice(1)))
}

// 计数排序
let countSort = arr =>{
  let hashTable = {}, max = 0, result = []
  for(let i=0; i<arr.length; i++){ // 遍历数组
    if(!(arr[i] in hashTable)){ 
      hashTable[arr[i]] = 1
    }else{
      hashTable[arr[i]] += 1
    }
    if(arr[i] > max) {max = arr[i]}
  }
  for(let j=0; j<=max; j++){ // 遍历哈希表
    if(j in hashTable){
      for(let i = 0; i<hashTable[j]; i++){
        result.push(j)
      }
    }
  }
  return result
}
</script>
</body>
</html>